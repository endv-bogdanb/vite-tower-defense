var j=Object.defineProperty;var I=(i,t,s)=>t in i?j(i,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[t]=s;var e=(i,t,s)=>(I(i,typeof t!="symbol"?t+"":t,s),s);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const m of a.addedNodes)m.tagName==="LINK"&&m.rel==="modulepreload"&&r(m)}).observe(document,{childList:!0,subtree:!0});function s(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(o){if(o.ep)return;o.ep=!0;const a=s(o);fetch(o.href,a)}})();class T extends HTMLElement{constructor(){super();e(this,"render",()=>{this.shadowRoot!=null&&this.shadowRoot.replaceChildren(this.styles,this.content)});this.attachShadow({mode:"open"})}static get observedAttributes(){return["count"]}connectedCallback(){this.render()}attributeChangedCallback(){this.render()}get content(){const s=document.createElement("div");return s.classList.add("wrapper"),s.innerHTML=`
    <slot></slot> 
    <span>${this.count}</span>
    `,s}get styles(){const s=document.createElement("style");return s.textContent=`
    .wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ffffff;
        font-size: 2rem;
        -webkit-text-stroke: 2px #000000;
        gap: 4px;
    }

    ::slotted(svg) {
        width: 64px;
        height: 64px;
    }
    `,s}get count(){return this.getAttribute("count")??""}}customElements.get("game-stats")==null&&customElements.define("game-stats",T);const F=["game-map","projectile","orc","tower","explosion"],d=class d{};e(d,"assets",new Map),e(d,"waypoints",[]),e(d,"tiles",[]),e(d,"load",async()=>{await Promise.all([F.map(d.loadImage),d.loadWaypoints(),d.loadTiles()])}),e(d,"loadImage",async t=>{await new Promise((s,r)=>{const o=new Image;o.onload=()=>{s()},o.onerror=r,o.src=`/assets/${t}.png`,d.assets.set(t,o)})}),e(d,"loadWaypoints",async()=>{const t=await fetch("/waypoints.json");if(!t.ok)throw new Error(`${t.statusText!==""||t.status}`);const s=await t.json();d.waypoints=s}),e(d,"loadTiles",async()=>{const t=await fetch("/tiles.json");if(!t.ok)throw new Error(`${t.statusText!==""||t.status}`);const s=await t.json();d.tiles=s});let p=d;class P{constructor(t,s,r){e(this,"currentFrame",0);this._position=t,this.width=s,this.height=r}get position(){return{...this._position}}get x(){return this._position.x}set x(t){this._position.x=t}get y(){return this._position.y}set y(t){this._position.y=t}get w(){return this.width}get h(){return this.height}get center(){return{x:this.x+this.w/2,y:this.y+this.h/2}}}class b extends P{constructor(s,r,o,a){super(s,r,o);e(this,"currentFrame",0);this.asset=a}update(){n.frames%this.asset.hold===0&&(this.currentFrame=(this.currentFrame+1)%this.asset.frames)}draw(){const s=p.assets.get(this.asset.src),r=s.width/this.asset.frames,o=s.height,a={x:r*this.currentFrame,y:0,w:r,h:o};n.ctx.drawImage(s,a.x,a.y,a.w,a.h,this.x+this.asset.offset.x,this.y+this.asset.offset.y,a.w,a.h)}}class O extends b{constructor(s){super(s,64*2,64,{src:"tower",frames:19,hold:5,offset:{x:0,y:-80}});e(this,"update",()=>{this.draw();const s=this.enemy();(s!=null||this.currentFrame!==0)&&super.update(),s!=null&&this.currentFrame===6&&n.frames%this.asset.hold===0&&l.shoot({x:this.center.x-20,y:this.center.y-110},s)});e(this,"draw",()=>{super.draw()});e(this,"debug",()=>{n.ctx.beginPath(),n.ctx.arc(this.center.x,this.center.y,this.w*2,0,Math.PI*2),n.ctx.fillStyle="rgba(0, 0, 255, 0.15)",n.ctx.fill()});e(this,"enemy",()=>l.enemies.find(s=>Math.hypot(s.center.y-this.center.y,s.center.x-this.center.x)<s.w+this.w*2))}}const M=(i,t)=>{let s=i.length;for(;s>0;)--s,t(i[s],s,i)},q=(i,t,s)=>{const r=Math.abs(Math.round(i.x)-Math.round(t.x)),o=Math.abs(Math.round(i.y)-Math.round(t.y));return r<Math.abs(s.x)&&o<Math.abs(s.y)},L=(i,t,s={x:0,y:0})=>i.x>t.x&&i.x<t.x+s.x&&i.y>t.y&&i.y<t.y+s.y;class k extends b{constructor(s){super(s,100,100,{src:"orc",frames:7,hold:5,offset:{x:0,y:0}});e(this,"waypointIndex",0);e(this,"health",100);e(this,"velocity",{x:0,y:0});e(this,"speed",3);e(this,"update",()=>{this.draw(),super.update(),this.updatePosition(),this.updateWaypointIndex(),this.isOffMap()});e(this,"draw",()=>{super.draw(),n.ctx.fillStyle="#ff0000",n.ctx.fillRect(this.x,this.y-15,this.w,10),n.ctx.fillStyle="#00ff00",n.ctx.fillRect(this.x,this.y-15,Math.max(0,this.w*this.health/100),10)});e(this,"debug",()=>{});e(this,"hit",()=>{this.health!==0&&(this.health=Math.max(0,this.health-20),this.health===0&&(l.removeEnemy(this),n.updateCoins()))});e(this,"updatePosition",()=>{const s=Math.atan2(this.waypoint.y-this.center.y,this.waypoint.x-this.center.x);this.velocity.x=Math.cos(s)*this.speed,this.velocity.y=Math.sin(s)*this.speed,this.x+=this.velocity.x,this.y+=this.velocity.y});e(this,"updateWaypointIndex",()=>{q(this.center,this.waypoint,this.velocity)&&(this.waypointIndex=Math.min(this.waypointIndex+1,p.waypoints.length-1))});e(this,"isOffMap",()=>{this.x>y.canvas.width&&(l.removeEnemy(this),n.hit())})}get waypoint(){return p.waypoints[this.waypointIndex]}}class C extends b{constructor(s){super(s,10,10,{src:"explosion",frames:4,hold:5,offset:{x:0,y:0}});e(this,"update",()=>{this.draw(),super.update(),this.currentFrame===this.asset.frames-1&&l.removeExplosion(this)});e(this,"draw",()=>{super.draw()});e(this,"debug",()=>{})}}class R extends P{constructor(s,r="rgba(255, 255, 255, .15)",o=!1){super(s,64,64);e(this,"update",()=>{this.draw(),L(w.mouse,this.position,{x:this.w,y:this.h})?(this.color="rgba(255, 255, 255, 1)",l.activeTile=this):(this.color="rgba(255, 255, 255, .15)",l.activeTile===this&&(l.activeTile=void 0))});e(this,"draw",()=>{n.ctx.fillStyle=this.color,n.ctx.fillRect(this.x,this.y,this.w,this.h)});e(this,"debug",()=>{});this.color=r,this.occupied=o}}class $ extends b{constructor(s,r){super(s,10,10,{src:"projectile",frames:1,hold:5,offset:{x:0,y:0}});e(this,"velocity",{x:0,y:0});e(this,"speed",5);e(this,"update",()=>{this.draw();const s=Math.atan2(this.enemy.center.y-this.y,this.enemy.center.x-this.x);this.velocity.x=Math.cos(s),this.velocity.y=Math.sin(s),this.x+=this.velocity.x*this.speed,this.y+=this.velocity.y*this.speed,Math.hypot(this.enemy.center.x-this.x,this.enemy.center.y-this.y)<this.enemy.w+this.w&&(this.enemy.hit(),l.removeProjectile(this))});e(this,"draw",()=>{super.draw()});e(this,"debug",()=>{});this.enemy=r}}const c=class c{};e(c,"enemies",[]),e(c,"placementTiles",[]),e(c,"buildings",[]),e(c,"projectiles",[]),e(c,"explosions",[]),e(c,"activeTile"),e(c,"load",async()=>{c.loadEnemies(),c.loadPlacementTiles()}),e(c,"placeBuilding",()=>{const{activeTile:t}=c;t===void 0||t!=null&&t.occupied||n.coins-25<0||(c.buildings.push(new O(t.position)),c.buildings.sort((s,r)=>s.y-r.y),t.occupied=!0,n.updateCoins(-25))}),e(c,"shoot",(t,s)=>{c.projectiles.push(new $(t,s))}),e(c,"removeProjectile",t=>{const s=c.projectiles.indexOf(t);s>-1&&(c.projectiles.splice(s,1),c.explosions.push(new C(t.position)))}),e(c,"removeEnemy",t=>{const s=c.enemies.indexOf(t);s>-1&&c.enemies.splice(s,1)}),e(c,"removeExplosion",t=>{const s=c.explosions.indexOf(t);s>-1&&c.explosions.splice(s,1)}),e(c,"spawnEnemies",()=>{c.loadEnemies(y.spawnedEnemies+n.round)}),e(c,"loadEnemies",(t=y.spawnedEnemies)=>{const[{x:s,y:r}]=p.waypoints;for(let o=1;o<t+1;o+=1){const a=o*150;c.enemies.push(new k({x:s-a,y:r}))}}),e(c,"loadPlacementTiles",()=>{p.tiles.forEach((t,s)=>{t.forEach((r,o)=>{r===14&&c.placementTiles.push(new R({x:o*64,y:s*64}))})})});let l=c;const f=class f{};e(f,"mouse",{x:0,y:0}),e(f,"load",async()=>{window.addEventListener("mousemove",f.updateMouse,{passive:!0,capture:!0})}),e(f,"updateMouse",t=>{f.mouse.x=t.clientX,f.mouse.y=t.clientY});let w=f;class y{}e(y,"canvas",{width:1280,height:768}),e(y,"spawnedEnemies",3);const h=class h{static set context(t){this.ctx=t}};e(h,"loopHandle",0),e(h,"ctx"),e(h,"frames",0),e(h,"round",0),e(h,"life",10),e(h,"coins",50),e(h,"tick",()=>{h.frames+=1}),e(h,"load",async()=>{await p.load(),await Promise.all([l.load(),w.load()]);const t=document.querySelector("#life");t==null||t.setAttribute("count",`${h.life}`);const s=document.querySelector("#coin");s==null||s.setAttribute("count",`${h.coins}`)}),e(h,"hit",()=>{h.life=Math.max(0,h.life-1);const t=document.querySelector("#life");t==null||t.setAttribute("count",`${h.life}`)}),e(h,"updateCoins",(t=25)=>{h.coins+=t;const s=document.querySelector("#coin");s==null||s.setAttribute("count",`${h.coins}`)}),e(h,"schedule",t=>{h.loopHandle=requestAnimationFrame(t)}),e(h,"unschedule",()=>{cancelAnimationFrame(h.loopHandle)});let n=h;const x=class x{};e(x,"time",{elapsed:0,delta:0}),e(x,"updateTime",t=>{x.time.delta=t-x.time.elapsed,x.time.elapsed=t});let g=x;const u=class u{};e(u,"callback"),e(u,"start",async t=>{await n.load(),u.callback=t,n.schedule(u.loop)}),e(u,"stop",()=>{n.unschedule()}),e(u,"loop",t=>{g.updateTime(t),n.tick(),u.callback(g.time),n.schedule(u.loop)});let v=u;const H=()=>{if(n.ctx.fillStyle="#ffffff",n.ctx.fillRect(0,0,y.canvas.width,y.canvas.height),n.ctx.drawImage(p.assets.get("game-map"),0,0),n.life===0){v.stop();const i=document.querySelector("h1");i==null||i.setAttribute("style","display:block");return}l.enemies.length===0&&(n.round+=1,l.spawnEnemies()),M(l.enemies,i=>{i.update()}),M(l.explosions,i=>{i.update()}),l.placementTiles.forEach(i=>{i.update()}),l.buildings.forEach(i=>{i.update()}),M(l.projectiles,i=>{i.update()})};window.addEventListener("load",()=>{const i=document.querySelector("#app");i.width=y.canvas.width,i.height=y.canvas.height,n.context=i.getContext("2d"),v.start(H).then(()=>{i.addEventListener("click",()=>{l.placeBuilding()})},console.error)});
